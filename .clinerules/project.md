# プロジェクト仕様書: Stormworks リアルタイムビデオストリーマー (Electron移行)

## 1. プロジェクト概要

**目的:**
既存のPythonベースのビデオストリーミングサーバーを、Electron, React, TypeScript, Node.jsを使用して高性能なデスクトップアプリケーションに移行する。アプリケーションは、ローカルのビデオファイルから処理済みのビデオフレームを、ゲーム「Stormworks」内で実行されるLuaスクリプトに提供する。その主な目的は、データ転送率（Chunks Per Second, CPS）を最大化することである。

**コア機能:**
アプリケーションは、バックエンドサーバーを制御するためのシンプルなGUIを持つ。バックエンドはローカルのビデオファイル（`video.mp4`）を読み込み、各フレームを処理し、いくつかの最適化された形式のいずれかにエンコードし、リクエストに応じてHTTP経由でStormworksクライアントに送信する。パフォーマンス向上のため、元のPythonサーバーの全ロジックをNode.js (JavaScript/TypeScript) で再現する必要がある。

---

## 2. 現在の進捗状況 (2025/10/25時点)

プロジェクトは、Electronによるバックエンド実装の初期段階です。

* **完了:**
  * なし (Tauri/Rustの作業はElectron/Node.jsに移行するため破棄)

* **未実装 (TODO):**
  * Python版の `_handle_new_frame` と `_handle_get_chunk` に相当するHTTPリクエストハンドラ。
  * 動画ファイル (`video.mp4`) の読み込み、デコード、リサイズ処理 (例: `fluent-ffmpeg` や `node-ffmpeg` の利用)。
  * 仕様書に定められた6つのデータエンコード形式（F, FR, D, I, IR, DI）すべてのNode.js (JavaScript/TypeScript) による再実装。
  * フレームデータやパレットキャッシュなどの状態管理。
  * CPSや使用されたエンコード形式などの統計情報を、ElectronのIPC通信を介してリアルタイムにフロントエンドへ送信する機能。

**結論:** アプリケーションの骨格はまだ構築されていません。中心的なビデオ処理およびエンコード機能はまだ実装されていません。

---

## 3. 技術スタック

* **フレームワーク:** Electron
* **フロントエンド:** React with TypeScript
* **バックエンド:** Node.js with TypeScript

---

## 4. コンポーネントの責務

### 4.1. フロントエンド (React/TypeScript)

*   **目的:** サーバーを制御するためのユーザーインターフェースを提供する。
*   **UIコンポーネント:**
    *   「サーバー起動」/「サーバー停止」ボタン。
    *   HTTPサーバーのポート番号を設定する入力フィールド（デフォルト: 8000）。
    *   以下の情報を表示するステータス表示エリア:
        *   サーバーの状態（例: "停止中", "実行中", "エラー"）。
        *   リアルタイムで処理されている秒間チャンク数（CPS）。
        *   最後に送信されたフレームのデータ形式（例: "DIFF_INDEXED", "FULL_RLE"）。
*   **機能:**
    *   ElectronのIPC通信を介してNode.jsバックエンド（メインプロセス）と通信し、コマンド（例: 特定ポートでサーバーを起動/停止）を送信する。
    *   Node.jsバックエンドから発行されるイベントをリッスンし、ステータス表示をリアルタイムで更新する。

### 4.2. バックエンド (Node.js/TypeScript)

*   **目的:** すべての動画処理およびエンコードタスクを処理する。このコンポーネントは、元の `main.py` スクリプトを完全に置き換えるものである。
*   **コアタスク:**
    1.  **高性能HTTPサーバー:**
        *   `express` や `http` モジュールのようなNode.jsのウェブフレームワークを使用する。
        *   設定可能なポートでGETリクエストをリッスンする。
        *   元のPythonサーバーで定義された2つのエンドポイントを実装する:
            *   `/?action=new_frame`: 新しいフレームを準備し、最適なエンコードを選択し、メタデータと最初のデータチャンクを返す。
            *   `/?action=get_chunk`: 指定されたフレームの特定のデータチャンクを返す。
    2.  **ビデオ処理:**
        *   起動時に、アプリケーションのルートディレクトリから `video.mp4` を読み込む。
        *   FFmpegライブラリ（例: `fluent-ffmpeg` や `node-ffmpeg` などのNode.jsバインディング）を使用して、ビデオを個々のフレームにデコードする。
        *   各フレームをターゲット解像度である64x64ピクセルにリサイズする。
        *   ビデオが終了した場合、最初からループ再生する。
    3.  **データエンコーディングエンジン (再現必須のロジック):**
        *   Node.jsバックエンドは `main.py` の動的なデータ形式選択ロジックを再現しなければならない。新しいフレームごとに、以下の形式をすべて生成・比較し、最も小さいものを送信する。
        *   **実装すべき形式:**
            *   **Full (F):** 生のRGBピクセルデータ。Base64でエンコード。
            *   **Full RLE (FR):** フルフレームにランレングスエンコーディングを適用。ペイロード形式: `RRGGBB,count|RRGGBB,count|...` (すべて16進数)。
            *   **Diff (D):** 前のフレームから変更されたピクセルのみを送信。ペイロード形式: `pixel_index:RRGGBB|pixel_index:RRGGBB|...` (すべて16進数)。
            *   **Indexed (I):** 256色以下のフレーム用。カラーパレットと、それに続くパレットインデックスのストリームを送信。ペイロード形式: `palette_id|palette_data|indices_stream`。
            *   **Indexed RLE (IR):** インデックス形式の `indices_stream` にRLEを適用。ペイロード形式: `palette_id|palette_data|index,count|index,count|...`。
            *   **Diff Indexed (DI):** フルカラー値の代わりにパレットインデックスを使用する差分更新。ペイロード形式: `palette_id|palette_data|pixel_index:index|pixel_index:index|...`。
        *   **状態管理:** サーバーはフレーム間の状態を維持する必要がある。これには、差分計算用の前のフレームのピクセルデータや、最近使用したカラーパレットのキャッシュ（Python/Lua実装と一致するLRUキャッシュロジック）が含まれる。
    4.  **フロントエンドとの通信:**
        *   ElectronのIPC通信を介して、サーバーの起動/停止コマンドを受信する。
        *   リアルタイムのステータス更新（CPS、最後に使用した形式など）をフロントエンドに提供するためにイベントを発行する。

---

## 5. Stormworks Luaクライアント (ターゲット)

Node.jsサーバーの出力は、提供されているLuaクライアントと100%互換性がなければならない。クライアントは、チャンク化されたデータの受信、指定されたすべての形式のデコード、およびパレットキャッシュの管理を行う。

*   Luaクライアントソースコード: `stormworks-lua-script/MyMicrocontroller.lua`

---

## 6. 成功基準

*   最終的な成果物は、Electronによって作成された単一のクロスプラットフォーム実行ファイルであること。
*   アプリケーションのGUIが、Node.jsバックエンドサーバーの起動と停止を正常に行えること。
*   Node.jsサーバーが `video.mp4` からStormworksのLuaクライアントへビデオフレームを正しく提供できること。
*   6つすべてのデータエンコード形式が正しく実装され、期待通りに機能すること。
*   結果として得られるCPSが、Python実装で達成された10-18 CPSよりも大幅に高いこと。目標は、Stormworksの上限である60 CPSに可能な限り近づけること。
