# プロジェクト仕様書: Stormworks リアルタイムビデオストリーマー (v2.4)

## 1. プロジェクト概要

**目的:**
既存のElectronベースのビデオストリーマーをアップグレードし、クライアント（Stormworks Lua）の**実効スループット（CPS）**に基づいた**適応的ビットレート（ABR）**制御下で、安定した高フレームレート（目標: モノクロ 30FPS, カラー 15FPS）を実現する。

**コア戦略:**
UIで切り替え可能な2つの動作モードを定義する。

1. **無劣化 (Lossless) モード:** 既存の6種類の可逆圧縮（F, FR, D, I, IR, DI）を使用し、画質を最優先する。パレットは圧縮率が最適になるよう動的に選択する（3.1. 参照）。
2. **非可逆 (Lossy) モード:** 新開発のアルゴリズム **`PDI` (Prioritized Differential Indexed)** を使用し、画質を犠牲にしてでも安定したFPSを最優先する。

アーキテクチャは、クライアントからの動的な解像度・CPS報告に対応する**クライアントセッション管理**を必須とする。

---

## 2. アーキテクチャ（クライアントセッション管理）

### 2.1. クライアントセッション管理

* **目的:** 複数のStormworksクライアントに対し、それぞれ**独立した設定**（解像度、圧縮モード、目標FPS、画質）で同時にビデオストリームを配信する。
* **実装 (`main.ts`):**
  * `ClientSession` クラス（またはインターフェース）を定義する。
  * `ClientSessionManager: Map<string, ClientSession>` をグローバルに保持する。

### 2.2. クライアント識別とパラメータ通知 (重要)

* **Luaクライアント (`MyMicrocontroller.lua`):**
  * `onTick` 内の `new_frame` リクエストにおいて、URLパラメータで以下の情報を**必須**で送信する。
  * **URL例:** `/?action=new_frame&client_id=...&w=200&h=150&actual_cps=30.5&cached_pids=1,5,8`
    * `client_id`: サーバーから払い出された一意のID。**初回のみ `client_id=0` を送信**する。
    * `w`: クライアントが要求する**幅**。
    * `h`: クライアントが要求する**高さ**。
    * `actual_cps`: クライアントが現在処理できている**実効チャンク毎秒 (CPS)**。
    * `cached_pids`: クライアントが保持するパレットIDリスト。

* **サーバー (`main.ts`):**
  * `client_id=0` を受信した場合:
      1. `crypto.randomUUID()` などで新しい一意の `new_id` を生成する。
      2. `new_id` をキーに `ClientSession` を新規作成し、`ClientSessionManager` に登録する。
      3. HTTP応答の先頭に `NEW_ID:{new_id};` を付与して返す。（例: `NEW_ID:abc-123;{frame_id};...`）
  * `client_id` が存在する場合:
      1. `ClientSessionManager` から該当セッションを取得する。
      2. `w`, `h`, `actual_cps`, `cached_pids` の各パラメータを該当セッションの状態に反映・更新する。
      3. 通常の応答（`OK;{frame_id};...`）を返す。

* **Luaクライアント (`httpReply`):**
  * 応答が `NEW_ID:` で始まる場合、ID（`abc-123`）を抽出し、グローバル変数 `g_client_id` に保存する。次回以降、このIDを使用する。

### 2.3. `ClientSession` の状態

各 `ClientSession` は、以下の状態を独立して保持する。

| プロパティ | 型 | 説明 |
| :--- | :--- | :--- |
| `id` | `string` | `client_id`（サーバーが払い出したUUID）。 |
| `width`, `height` | `number` | クライアントが要求した解像度。 |
| `actualCps` | `number` | クライアントから報告された最新の実効CPS。 |
| `cachedPaletteIds` | `Set<number>` | クライアントがキャッシュ済みのパレットIDリスト。 |
| `settings` | `ClientSettings` | UIから設定される配信設定（下記参照）。 |
| `server_lossy_frame_buffer` | `Buffer \| null` | **非可逆モード用。**クライアントと同期された「劣化版」フレームバッファ。 |
| `prevFrameBuffer` | `Buffer \| null` | **可逆モード用。**差分（`D`, `DI`）計算のための「完璧な」前フレームバッファ。 |
| `ffmpegProcess` | `FfmpegCommand \| null` | このセッション（またはこの解像度）専用のFFmpegプロセス。 |

### 2.4. `ClientSettings` の状態

UIから動的に変更され、`ClientSession` に保持される設定項目。

| プロパティ | 型 | 説明 |
| :--- | :--- | :--- |
| `mode` | `'Lossless' \| 'Lossy'` | 圧縮モード。「無劣化」または「非可逆」。 |
| `targetFps` | `number` | 非可逆モード時の**目標**FPS（例: 15）。 |
| `qualityThreshold` | `number` | **非可逆モード時の画質閾値（例: 0〜255）。**詳細は 3.2. を参照。 |
| `colorMode` | `'Color' \| 'Mono'` | 配信モード（カラーまたはモノクロ）。 |
| `lossyMaxPaletteSize` | `number` | **非可逆モード時の最大パレット色数**（例: 16, 32, 64）。 |

---

## 3. エンコードモード仕様

### 3.1. 無劣化 (Lossless) モード

* **動作:** 既存の動作を踏襲。`settings.mode` が `Lossless` の場合に実行される。
* **ロジック:** 6種類（F, FR, D, I, IR, DI）のペイロードをすべて生成し、最もデータサイズが小さいものを選択して送信する。
* **状態:** `prevFrameBuffer` のみを使用・更新する。`server_lossy_frame_buffer` は使用しない。
* **モード切替:** `Lossy`から`Lossless`に切り替えた瞬間、`prevFrameBuffer`は`null`のため、`F`または`FR`が送信される。**この瞬間のFPS低下は許容する。**
* **パレット戦略 (I, IR, DI):**
    1. `main.ts`はフレーム内の実際の色数（`unique_colors.length`）をカウントする。
    2. 色数が**16色以下**の場合、パレットインデックスを**4ビット**でエンコードする形式（`I4`, `IR4`, `DI4`など、Lua側との合意が必要）を優先的に試行する。
    3. 色数が**17〜256色**の場合、既存の8ビットインデックス形式（`I`, `IR`, `DI`）を使用する。

### 3.2. 非可逆 (Lossy) モード - アルゴリズム `PDI`

* **名称:** `PDI` (Prioritized Differential Indexed - 優先度付き差分インデックス)
* **目的:** クライアントの**実効帯域幅**（`actual_cps` から計算）と**目標FPS**（`targetFps`）に基づいて1フレームあたりの**予算（`TARGET_BYTES`）**を厳密に計算し、その予算内に収まるよう**三段構えの量子化**を適用する。

#### `PDI` の処理フロー (`main.ts`)

1. **適応的ビットレート（ABR）予算の計算:**
    * クライアント報告の `actual_cps` と `CHUNK_SIZE_LIMIT`（定数: 4000）から、**実効帯域幅（bps）**を計算する。
        * `const effective_bandwidth_bps = session.actualCps * CHUNK_SIZE_LIMIT * 8;`
    * UI設定の `settings.targetFps` を取得する。
    * **1フレームあたりの予算（`TARGET_BYTES`）**を決定する。
        * `const TARGET_BYTES = Math.floor(effective_bandwidth_bps / 8 / settings.targetFps) - 100; // マージン100バイト`

2. **誤差（優先度）の計算:**
    * FFmpegからの「完璧な新フレーム」と、セッションの `server_lossy_frame_buffer`（劣化版フレーム）との**絶対差分（誤差）**を全ピクセルで計算する。

3. **第1段階: ピクセル破棄（`qualityThreshold`）:**
    * UIの「画質スライダー」から設定された `settings.qualityThreshold`（例: 15）を取得する。
    * **スライダーの役割:** この `qualityThreshold` は、「どれだけ小さな色の変化までを更新対象として拾い上げるか」の閾値となる。
    * 誤差（`priority`）が `qualityThreshold` 未満のピクセルは、**この時点で「破棄」**し、送信候補リストから除外する。
    * 送信候補リストを誤差（`priority`）の降順でソートする。

4. **第2段階: 段階的量子化（デルタのビット深度制限）:**
    * `TARGET_BYTES`（予算）からヘッダサイズやインデックスサイズを引いた「ピクセルデータに使える残り予算（ビット数）」を計算する。
    * 送信候補リストのピクセル数で「残り予算」を割り、**「1ピクセルあたりに割り当て可能な差分ビット数（デルタ・ビット深度）」**を動的に計算する。（例: 4000ビット / 1000ピクセル = 4ビット/ピクセル）
    * この「デルタ・ビット深度」に基づき、各ピクセルの**差分（デルタ）のダイナミックレンジを制限**し、「中間色」を計算する。（例: 8ビットの差分 `-80` が 4ビットの差分 `-8` に制限される）

5. **第3段階: パレット量子化（色数の制限）:**
    * UI設定の `settings.lossyMaxPaletteSize`（例: 64色）を取得する。
    * ステップ4で計算した「中間色」のリストを、この**64色**のパレットに強制的に量子化（丸め込み）する。
    * 各「中間色」について、この64色パレット内の**「最近傍色」**を探し、そのインデックスを取得する。

6. **ペイロード構築と状態更新:**
    * 各ピクセルについて、ペイロード（`{pixel_index}:{palette_index}|...`）を構築する。
    * サーバー側の `server_lossy_frame_buffer` を、ステップ5で決定した**「最近傍色」**で更新する。

7. **予算超過の制御（近似）:**
    * 上記の処理（特にパレット量子化やRLE圧縮）により、最終的なペイロードが `TARGET_BYTES` を超過、または大幅に下回る可能性がある。これは**許容**する。
    * `TARGET_BYTES` は、厳密な上限ではなく、**「近似させるための目標値」**として扱う。

8. **キーフレーム (`KFQ`) の処理:**
    * モード切替時やシーク時など、`server_lossy_frame_buffer` が `null` の場合、`PDI` は送信しない。
    * 代わりに、`I` や `IR` 形式を `TARGET_BYTES` の予算内で送信する**キーフレーム（`KFQ_I` や `KFQ_IR` など）**を送信し、`server_lossy_frame_buffer` を初期化する。

### 3.3. モノクロモードの定義 (`settings.colorMode = 'Mono'`)

* **FFmpeg:** `ffmpeg`の出力オプションで`-pix_fmt gray`を使用する。サーバーが扱うフレームデータはピクセルあたり8ビット（0〜255）となる。
* **パレット:** `I`, `PDI` 等でパレットを作成する場合、そのパレットは `[ [10], [25], [150], [240] ]` のような、グレースケール値（1チャンネル）のリストとして扱われる。
* **パレット戦略:** 可逆・非可逆モードともに、3.1.および3.2.で定義したパレット戦略（動的ビット深度、最大色数制限）が同様に適用される。

---

## 4. Luaクライアントの変更 (`MyMicrocontroller.lua`)

1. **解像度とIDの送信 (必須):**
    * グローバル変数 `g_client_id = "0"` を定義する。
    * `onTick` 内の `new_frame` リクエストに `client_id`, `w`, `h`, `actual_cps` を含める（2.2. 参照）。
2. **IDの受信 (必須):**
    * `httpReply` で応答が `NEW_ID:` で始まる場合、IDを抽出し `g_client_id` に保存する。
3. **`PDI` 形式のデコード:**
    * `httpReply` 内に `PDI` 用の `elseif update_type == "PDI"` を追加する。デコードロジックは既存の `DI` 形式と**全く同一**で良い。
4. **`KFQ` 形式のデコード:**
    * `KFQ_I`, `KFQ_IR` など、キーフレーム用のデコードロジックを追加する（`I` や `IR` と同一で良い）。
5. **差分適用の修正（重要）:**
    * `D`, `DI`, `PDI` などの差分系形式を受信した場合、デコード処理の**直前に**、`display_pixel_data`（現在表示中のフレーム）の内容を `download_pixel_data`（作業バッファ）に**全コピー**する処理を追加する。

---

## 5. UI（フロントエンド）の要求仕様

### 5.1. クライアント一覧（新規）

* **UI:** テーブル表示。
* **内容:** `Client ID`, `IP Address`, `Resolution`, `Mode`, `Target FPS`, `Actual CPS`, `Last Format` などを `ClientSessionManager` から取得して一覧表示する。
* **機能:** リストの項目をクリックすると、そのクライアントの**個別設定（下記 5.2.）**を編集できるパネルを表示する。

### 5.2. クライアント個別設定パネル

1. **対象クライアント:** （「`Client ID: ...`」を表示）
2. **モノクロ/カラー切替:**
    * **UI:** トグルスイッチ（`Mono` / `Color`）。
    * **動作:** 該当セッションの `settings.colorMode` を変更する。
3. **圧縮モード切替:**
    * **UI:** ラジオボタン（`無劣化 (Lossless)` / `非可逆 (Lossy)`）。
    * **動作:** 該当セッションの `settings.mode` を変更する。
4. **目標FPSスライダー (非可逆モード時のみ表示):**
    * **UI:** スライダー（例: 5 FPS 〜 30 FPS）。
    * **動作:** 該当セッションの `settings.targetFps` を変更する。
5. **画質スライダー (非可逆モード時のみ表示):**
    * **UI:** スライダー（「FPS優先 (低画質)」 ⟷ 「画質優先 (FPS不安定)」）。
    * **動作:** 該当セッションの `settings.qualityThreshold` を変更する。
    * **役割:** **「どれだけ小さな色の変化までを更新対象として拾い上げるか」**の閾値（`PDI`のステップ3）を設定する。
6. **最大パレット色数 (非可逆モード時のみ表示):**
    * **UI:** ドロップダウンまたはスライダー（例: 16, 32, 64, 128, 256）。
    * **動作:** 該当セッションの `settings.lossyMaxPaletteSize` を変更する（`PDI`のステップ5で使用）。

---

## 6. 将来的な展望（2パスエンコード）

現在の `PDI` アルゴリズムは、1パスで量子化とパレット化を行うため、予算（`TARGET_BYTES`）への近似精度には限界がある。

将来的に、サーバーの処理能力に余裕があれば、以下のような**2パス（または3パス）エンコード**の実装が考えられる。

1. **1パス目（分析）:** フレーム全体を分析し、最適なパレットを生成し、各ピクセルの優先度と量子化に必要なビット数を計算する。
2. **2パス目（適用）:** 1パス目の情報に基づき、予算内に収まるようピクセルを選択・量子化し、RLE圧縮も考慮して最終的なペイロードを構築する。

これにより、パレット量子化やRLEによる誤差を埋め、より厳密に目標ビットレートに近似させることが可能になる。
